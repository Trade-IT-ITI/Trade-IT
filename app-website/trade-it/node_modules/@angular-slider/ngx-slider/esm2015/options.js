/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const LabelType = {
    /** Label above low pointer */
    Low: 0,
    /** Label above high pointer */
    High: 1,
    /** Label for minimum slider value */
    Floor: 2,
    /** Label for maximum slider value */
    Ceil: 3,
    /** Label below legend tick */
    TickValue: 4,
};
export { LabelType };
LabelType[LabelType.Low] = 'Low';
LabelType[LabelType.High] = 'High';
LabelType[LabelType.Floor] = 'Floor';
LabelType[LabelType.Ceil] = 'Ceil';
LabelType[LabelType.TickValue] = 'TickValue';
/** @typedef {?} */
var TranslateFunction;
export { TranslateFunction };
/** @typedef {?} */
var CombineLabelsFunction;
export { CombineLabelsFunction };
/** @typedef {?} */
var GetLegendFunction;
export { GetLegendFunction };
/** @typedef {?} */
var GetStepLegendFunction;
export { GetStepLegendFunction };
/** @typedef {?} */
var ValueToPositionFunction;
export { ValueToPositionFunction };
/** @typedef {?} */
var PositionToValueFunction;
export { PositionToValueFunction };
/**
 * Custom step definition
 *
 * This can be used to specify custom values and legend values for slider ticks
 * @record
 */
export function CustomStepDefinition() { }
/**
 * Value
 * @type {?}
 */
CustomStepDefinition.prototype.value;
/**
 * Legend (label for the value)
 * @type {?|undefined}
 */
CustomStepDefinition.prototype.legend;
/**
 * Slider options
 */
export class Options {
    constructor() {
        /**
         * Minimum value for a slider.
         * Not applicable when using stepsArray.
         */
        this.floor = 0;
        /**
         * Maximum value for a slider.
         * Not applicable when using stepsArray.
         */
        this.ceil = null;
        /**
         * Step between each value.
         * Not applicable when using stepsArray.
         */
        this.step = 1;
        /**
         * The minimum range authorized on the slider.
         * Applies to range slider only.
         * When using stepsArray, expressed as index into stepsArray.
         */
        this.minRange = null;
        /**
         * The maximum range authorized on the slider.
         * Applies to range slider only.
         * When using stepsArray, expressed as index into stepsArray.
         */
        this.maxRange = null;
        /**
         * Set to true to have a push behavior. When the min handle goes above the max,
         * the max is moved as well (and vice-versa). The range between min and max is
         * defined by the step option (defaults to 1) and can also be overriden by
         * the minRange option. Applies to range slider only.
         */
        this.pushRange = false;
        /**
         * The minimum value authorized on the slider.
         * When using stepsArray, expressed as index into stepsArray.
         */
        this.minLimit = null;
        /**
         * The maximum value authorized on the slider.
         * When using stepsArray, expressed as index into stepsArray.
         */
        this.maxLimit = null;
        /**
         * Custom translate function. Use this if you want to translate values displayed
         * on the slider.
         */
        this.translate = null;
        /**
         * Custom function for combining overlapping labels in range slider.
         * It takes the min and max values (already translated with translate fuction)
         * and should return how these two values should be combined.
         * If not provided, the default function will join the two values with
         * ' - ' as separator.
         */
        this.combineLabels = null;
        /**
         * Use to display legend under ticks (thus, it needs to be used along with
         * showTicks or showTicksValues). The function will be called with each tick
         * value and returned content will be displayed under the tick as a legend.
         * If the returned value is null, then no legend is displayed under
         * the corresponding tick.You can also directly provide the legend values
         * in the stepsArray option.
         */
        this.getLegend = null;
        /**
         * Use to display a custom legend of a stepItem from stepsArray.
         * It will be the same as getLegend but for stepsArray.
         */
        this.getStepLegend = null;
        /**
         * If you want to display a slider with non linear/number steps.
         * Just pass an array with each slider value and that's it; the floor, ceil and step settings
         * of the slider will be computed automatically.
         * By default, the value model and valueHigh model values will be the value of the selected item
         * in the stepsArray.
         * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray
         * option to true.
         */
        this.stepsArray = null;
        /**
         * Set to true to bind the index of the selected item to value model and valueHigh model.
         */
        this.bindIndexForStepsArray = false;
        /**
         * When set to true and using a range slider, the range can be dragged by the selection bar.
         * Applies to range slider only.
         */
        this.draggableRange = false;
        /**
         * Same as draggableRange but the slider range can't be changed.
         * Applies to range slider only.
         */
        this.draggableRangeOnly = false;
        /**
         * Set to true to always show the selection bar before the slider handle.
         */
        this.showSelectionBar = false;
        /**
         * Set to true to always show the selection bar after the slider handle.
         */
        this.showSelectionBarEnd = false;
        /**
         * Set a number to draw the selection bar between this value and the slider handle.
         * When using stepsArray, expressed as index into stepsArray.
         */
        this.showSelectionBarFromValue = null;
        /**
         * Only for range slider. Set to true to visualize in different colour the areas
         * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.
         */
        this.showOuterSelectionBars = false;
        /**
         * Set to true to hide pointer labels
         */
        this.hidePointerLabels = false;
        /**
         * Set to true to hide min / max labels
         */
        this.hideLimitLabels = false;
        /**
         * Set to false to disable the auto-hiding behavior of the limit labels.
         */
        this.autoHideLimitLabels = true;
        /**
         * Set to true to make the slider read-only.
         */
        this.readOnly = false;
        /**
         * Set to true to disable the slider.
         */
        this.disabled = false;
        /**
         * Set to true to display a tick for each step of the slider.
         */
        this.showTicks = false;
        /**
         * Set to true to display a tick and the step value for each step of the slider..
         */
        this.showTicksValues = false;
        /* The step between each tick to display. If not set, the step value is used.
            Not used when ticksArray is specified. */
        this.tickStep = null;
        /* The step between displaying each tick step value.
            If not set, then tickStep or step is used, depending on which one is set. */
        this.tickValueStep = null;
        /**
         * Use to display ticks at specific positions.
         * The array contains the index of the ticks that should be displayed.
         * For example, [0, 1, 5] will display a tick for the first, second and sixth values.
         */
        this.ticksArray = null;
        /**
         * Used to display a tooltip when a tick is hovered.
         * Set to a function that returns the tooltip content for a given value.
         */
        this.ticksTooltip = null;
        /**
         * Same as ticksTooltip but for ticks values.
         */
        this.ticksValuesTooltip = null;
        /**
         * Set to true to display the slider vertically.
         * The slider will take the full height of its parent.
         * Changing this value at runtime is not currently supported.
         */
        this.vertical = false;
        /**
         * Function that returns the current color of the selection bar.
         * If your color won't change, don't use this option but set it through CSS.
         * If the returned color depends on a model value (either value or valueHigh),
         * you should use the argument passed to the function.
         * Indeed, when the function is called, there is no certainty that the model
         * has already been updated.
         */
        this.getSelectionBarColor = null;
        /**
         * Function that returns the color of a tick. showTicks must be enabled.
         */
        this.getTickColor = null;
        /**
         * Function that returns the current color of a pointer.
         * If your color won't change, don't use this option but set it through CSS.
         * If the returned color depends on a model value (either value or valueHigh),
         * you should use the argument passed to the function.
         * Indeed, when the function is called, there is no certainty that the model has already been updated.
         * To handle range slider pointers independently, you should evaluate pointerType within the given
         * function where "min" stands for value model and "max" for valueHigh model values.
         */
        this.getPointerColor = null;
        /**
         * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:
         * Left/bottom arrows: -1
         * Right/top arrows: +1
         * Page-down: -10%
         * Page-up: +10%
         * Home: minimum value
         * End: maximum value
         */
        this.keyboardSupport = true;
        /**
         * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2
         * so that the slider is rendered properly and the events are handled correctly.
         */
        this.scale = 1;
        /**
         * If you display the slider in an element that uses transform: rotate(90deg), set the rotate value to 90
         * so that the slider is rendered properly and the events are handled correctly. Value is in degrees.
         */
        this.rotate = 0;
        /**
         * Set to true to force the value(s) to be rounded to the step, even when modified from the outside.
         * When set to false, if the model values are modified from outside the slider, they are not rounded
         * and can be between two steps.
         */
        this.enforceStep = true;
        /**
         * Set to true to force the value(s) to be normalised to allowed range (floor to ceil), even when modified from the outside.
         * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
         * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
         */
        this.enforceRange = true;
        /**
         * Set to true to force the value(s) to be rounded to the nearest step value, even when modified from the outside.
         * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
         * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
         */
        this.enforceStepsArray = true;
        /**
         * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.
         */
        this.noSwitching = false;
        /**
         * Set to true to only bind events on slider handles.
         */
        this.onlyBindHandles = false;
        /**
         * Set to true to show graphs right to left.
         * If vertical is true it will be from top to bottom and left / right arrow functions reversed.
         */
        this.rightToLeft = false;
        /**
         * Set to true to reverse keyboard navigation:
         * Right/top arrows: -1
         * Left/bottom arrows: +1
         * Page-up: -10%
         * Page-down: +10%
         * End: minimum value
         * Home: maximum value
         */
        this.reversedControls = false;
        /**
         * Set to true to keep the slider labels inside the slider bounds.
         */
        this.boundPointerLabels = true;
        /**
         * Set to true to use a logarithmic scale to display the slider.
         */
        this.logScale = false;
        /**
         * Function that returns the position on the slider for a given value.
         * The position must be a percentage between 0 and 1.
         * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
         */
        this.customValueToPosition = null;
        /**
         * Function that returns the value for a given position on the slider.
         * The position is a percentage between 0 and 1.
         * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
         */
        this.customPositionToValue = null;
        /**
         * Precision limit for calculated values.
         * Values used in calculations will be rounded to this number of significant digits
         * to prevent accumulating small floating-point errors.
         */
        this.precisionLimit = 12;
        /**
         * Use to display the selection bar as a gradient.
         * The given object must contain from and to properties which are colors.
         */
        this.selectionBarGradient = null;
        /**
         * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.
         */
        this.ariaLabel = 'ngx-slider';
        /**
         * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.
         * Adds the aria-labelledby attribute.
         */
        this.ariaLabelledBy = null;
        /**
         * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.
         */
        this.ariaLabelHigh = 'ngx-slider-max';
        /**
         * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.
         * Adds the aria-labelledby attribute.
         */
        this.ariaLabelledByHigh = null;
        /**
         * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle
         */
        this.handleDimension = null;
        /**
         * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar
         */
        this.barDimension = null;
        /**
         * Enable/disable CSS animations
         */
        this.animate = true;
        /**
         * Enable/disable CSS animations while moving the slider
         */
        this.animateOnMove = false;
    }
}
if (false) {
    /**
     * Minimum value for a slider.
     * Not applicable when using stepsArray.
     * @type {?}
     */
    Options.prototype.floor;
    /**
     * Maximum value for a slider.
     * Not applicable when using stepsArray.
     * @type {?}
     */
    Options.prototype.ceil;
    /**
     * Step between each value.
     * Not applicable when using stepsArray.
     * @type {?}
     */
    Options.prototype.step;
    /**
     * The minimum range authorized on the slider.
     * Applies to range slider only.
     * When using stepsArray, expressed as index into stepsArray.
     * @type {?}
     */
    Options.prototype.minRange;
    /**
     * The maximum range authorized on the slider.
     * Applies to range slider only.
     * When using stepsArray, expressed as index into stepsArray.
     * @type {?}
     */
    Options.prototype.maxRange;
    /**
     * Set to true to have a push behavior. When the min handle goes above the max,
     * the max is moved as well (and vice-versa). The range between min and max is
     * defined by the step option (defaults to 1) and can also be overriden by
     * the minRange option. Applies to range slider only.
     * @type {?}
     */
    Options.prototype.pushRange;
    /**
     * The minimum value authorized on the slider.
     * When using stepsArray, expressed as index into stepsArray.
     * @type {?}
     */
    Options.prototype.minLimit;
    /**
     * The maximum value authorized on the slider.
     * When using stepsArray, expressed as index into stepsArray.
     * @type {?}
     */
    Options.prototype.maxLimit;
    /**
     * Custom translate function. Use this if you want to translate values displayed
     * on the slider.
     * @type {?}
     */
    Options.prototype.translate;
    /**
     * Custom function for combining overlapping labels in range slider.
     * It takes the min and max values (already translated with translate fuction)
     * and should return how these two values should be combined.
     * If not provided, the default function will join the two values with
     * ' - ' as separator.
     * @type {?}
     */
    Options.prototype.combineLabels;
    /**
     * Use to display legend under ticks (thus, it needs to be used along with
     * showTicks or showTicksValues). The function will be called with each tick
     * value and returned content will be displayed under the tick as a legend.
     * If the returned value is null, then no legend is displayed under
     * the corresponding tick.You can also directly provide the legend values
     * in the stepsArray option.
     * @type {?}
     */
    Options.prototype.getLegend;
    /**
     * Use to display a custom legend of a stepItem from stepsArray.
     * It will be the same as getLegend but for stepsArray.
     * @type {?}
     */
    Options.prototype.getStepLegend;
    /**
     * If you want to display a slider with non linear/number steps.
     * Just pass an array with each slider value and that's it; the floor, ceil and step settings
     * of the slider will be computed automatically.
     * By default, the value model and valueHigh model values will be the value of the selected item
     * in the stepsArray.
     * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray
     * option to true.
     * @type {?}
     */
    Options.prototype.stepsArray;
    /**
     * Set to true to bind the index of the selected item to value model and valueHigh model.
     * @type {?}
     */
    Options.prototype.bindIndexForStepsArray;
    /**
     * When set to true and using a range slider, the range can be dragged by the selection bar.
     * Applies to range slider only.
     * @type {?}
     */
    Options.prototype.draggableRange;
    /**
     * Same as draggableRange but the slider range can't be changed.
     * Applies to range slider only.
     * @type {?}
     */
    Options.prototype.draggableRangeOnly;
    /**
     * Set to true to always show the selection bar before the slider handle.
     * @type {?}
     */
    Options.prototype.showSelectionBar;
    /**
     * Set to true to always show the selection bar after the slider handle.
     * @type {?}
     */
    Options.prototype.showSelectionBarEnd;
    /**
     * Set a number to draw the selection bar between this value and the slider handle.
     * When using stepsArray, expressed as index into stepsArray.
     * @type {?}
     */
    Options.prototype.showSelectionBarFromValue;
    /**
     * Only for range slider. Set to true to visualize in different colour the areas
     * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.
     * @type {?}
     */
    Options.prototype.showOuterSelectionBars;
    /**
     * Set to true to hide pointer labels
     * @type {?}
     */
    Options.prototype.hidePointerLabels;
    /**
     * Set to true to hide min / max labels
     * @type {?}
     */
    Options.prototype.hideLimitLabels;
    /**
     * Set to false to disable the auto-hiding behavior of the limit labels.
     * @type {?}
     */
    Options.prototype.autoHideLimitLabels;
    /**
     * Set to true to make the slider read-only.
     * @type {?}
     */
    Options.prototype.readOnly;
    /**
     * Set to true to disable the slider.
     * @type {?}
     */
    Options.prototype.disabled;
    /**
     * Set to true to display a tick for each step of the slider.
     * @type {?}
     */
    Options.prototype.showTicks;
    /**
     * Set to true to display a tick and the step value for each step of the slider..
     * @type {?}
     */
    Options.prototype.showTicksValues;
    /** @type {?} */
    Options.prototype.tickStep;
    /** @type {?} */
    Options.prototype.tickValueStep;
    /**
     * Use to display ticks at specific positions.
     * The array contains the index of the ticks that should be displayed.
     * For example, [0, 1, 5] will display a tick for the first, second and sixth values.
     * @type {?}
     */
    Options.prototype.ticksArray;
    /**
     * Used to display a tooltip when a tick is hovered.
     * Set to a function that returns the tooltip content for a given value.
     * @type {?}
     */
    Options.prototype.ticksTooltip;
    /**
     * Same as ticksTooltip but for ticks values.
     * @type {?}
     */
    Options.prototype.ticksValuesTooltip;
    /**
     * Set to true to display the slider vertically.
     * The slider will take the full height of its parent.
     * Changing this value at runtime is not currently supported.
     * @type {?}
     */
    Options.prototype.vertical;
    /**
     * Function that returns the current color of the selection bar.
     * If your color won't change, don't use this option but set it through CSS.
     * If the returned color depends on a model value (either value or valueHigh),
     * you should use the argument passed to the function.
     * Indeed, when the function is called, there is no certainty that the model
     * has already been updated.
     * @type {?}
     */
    Options.prototype.getSelectionBarColor;
    /**
     * Function that returns the color of a tick. showTicks must be enabled.
     * @type {?}
     */
    Options.prototype.getTickColor;
    /**
     * Function that returns the current color of a pointer.
     * If your color won't change, don't use this option but set it through CSS.
     * If the returned color depends on a model value (either value or valueHigh),
     * you should use the argument passed to the function.
     * Indeed, when the function is called, there is no certainty that the model has already been updated.
     * To handle range slider pointers independently, you should evaluate pointerType within the given
     * function where "min" stands for value model and "max" for valueHigh model values.
     * @type {?}
     */
    Options.prototype.getPointerColor;
    /**
     * Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:
     * Left/bottom arrows: -1
     * Right/top arrows: +1
     * Page-down: -10%
     * Page-up: +10%
     * Home: minimum value
     * End: maximum value
     * @type {?}
     */
    Options.prototype.keyboardSupport;
    /**
     * If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2
     * so that the slider is rendered properly and the events are handled correctly.
     * @type {?}
     */
    Options.prototype.scale;
    /**
     * If you display the slider in an element that uses transform: rotate(90deg), set the rotate value to 90
     * so that the slider is rendered properly and the events are handled correctly. Value is in degrees.
     * @type {?}
     */
    Options.prototype.rotate;
    /**
     * Set to true to force the value(s) to be rounded to the step, even when modified from the outside.
     * When set to false, if the model values are modified from outside the slider, they are not rounded
     * and can be between two steps.
     * @type {?}
     */
    Options.prototype.enforceStep;
    /**
     * Set to true to force the value(s) to be normalised to allowed range (floor to ceil), even when modified from the outside.
     * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
     * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
     * @type {?}
     */
    Options.prototype.enforceRange;
    /**
     * Set to true to force the value(s) to be rounded to the nearest step value, even when modified from the outside.
     * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,
     * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.
     * @type {?}
     */
    Options.prototype.enforceStepsArray;
    /**
     * Set to true to prevent to user from switching the min and max handles. Applies to range slider only.
     * @type {?}
     */
    Options.prototype.noSwitching;
    /**
     * Set to true to only bind events on slider handles.
     * @type {?}
     */
    Options.prototype.onlyBindHandles;
    /**
     * Set to true to show graphs right to left.
     * If vertical is true it will be from top to bottom and left / right arrow functions reversed.
     * @type {?}
     */
    Options.prototype.rightToLeft;
    /**
     * Set to true to reverse keyboard navigation:
     * Right/top arrows: -1
     * Left/bottom arrows: +1
     * Page-up: -10%
     * Page-down: +10%
     * End: minimum value
     * Home: maximum value
     * @type {?}
     */
    Options.prototype.reversedControls;
    /**
     * Set to true to keep the slider labels inside the slider bounds.
     * @type {?}
     */
    Options.prototype.boundPointerLabels;
    /**
     * Set to true to use a logarithmic scale to display the slider.
     * @type {?}
     */
    Options.prototype.logScale;
    /**
     * Function that returns the position on the slider for a given value.
     * The position must be a percentage between 0 and 1.
     * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
     * @type {?}
     */
    Options.prototype.customValueToPosition;
    /**
     * Function that returns the value for a given position on the slider.
     * The position is a percentage between 0 and 1.
     * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.
     * @type {?}
     */
    Options.prototype.customPositionToValue;
    /**
     * Precision limit for calculated values.
     * Values used in calculations will be rounded to this number of significant digits
     * to prevent accumulating small floating-point errors.
     * @type {?}
     */
    Options.prototype.precisionLimit;
    /**
     * Use to display the selection bar as a gradient.
     * The given object must contain from and to properties which are colors.
     * @type {?}
     */
    Options.prototype.selectionBarGradient;
    /**
     * Use to add a label directly to the slider for accessibility. Adds the aria-label attribute.
     * @type {?}
     */
    Options.prototype.ariaLabel;
    /**
     * Use instead of ariaLabel to reference the id of an element which will be used to label the slider.
     * Adds the aria-labelledby attribute.
     * @type {?}
     */
    Options.prototype.ariaLabelledBy;
    /**
     * Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute.
     * @type {?}
     */
    Options.prototype.ariaLabelHigh;
    /**
     * Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.
     * Adds the aria-labelledby attribute.
     * @type {?}
     */
    Options.prototype.ariaLabelledByHigh;
    /**
     * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle
     * @type {?}
     */
    Options.prototype.handleDimension;
    /**
     * Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar
     * @type {?}
     */
    Options.prototype.barDimension;
    /**
     * Enable/disable CSS animations
     * @type {?}
     */
    Options.prototype.animate;
    /**
     * Enable/disable CSS animations while moving the slider
     * @type {?}
     */
    Options.prototype.animateOnMove;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXNsaWRlci9uZ3gtc2xpZGVyLyIsInNvdXJjZXMiOlsib3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0lBS0UsTUFBRzs7SUFFSCxPQUFJOztJQUVKLFFBQUs7O0lBRUwsT0FBSTs7SUFFSixZQUFTOzs7b0JBUlQsR0FBRztvQkFFSCxJQUFJO29CQUVKLEtBQUs7b0JBRUwsSUFBSTtvQkFFSixTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QlgsTUFBTTs7Ozs7O3FCQUdhLENBQUM7Ozs7O29CQUlGLElBQUk7Ozs7O29CQUlKLENBQUM7Ozs7Ozt3QkFLRyxJQUFJOzs7Ozs7d0JBS0osSUFBSTs7Ozs7Ozt5QkFNRixLQUFLOzs7Ozt3QkFJUCxJQUFJOzs7Ozt3QkFJSixJQUFJOzs7Ozt5QkFJUSxJQUFJOzs7Ozs7Ozs2QkFPSSxJQUFJOzs7Ozs7Ozs7eUJBUVosSUFBSTs7Ozs7NkJBSUksSUFBSTs7Ozs7Ozs7OzswQkFTTixJQUFJOzs7O3NDQUdQLEtBQUs7Ozs7OzhCQUliLEtBQUs7Ozs7O2tDQUlELEtBQUs7Ozs7Z0NBR1AsS0FBSzs7OzttQ0FHRixLQUFLOzs7Ozt5Q0FJQSxJQUFJOzs7OztzQ0FJTixLQUFLOzs7O2lDQUdWLEtBQUs7Ozs7K0JBR1AsS0FBSzs7OzttQ0FHRCxJQUFJOzs7O3dCQUdmLEtBQUs7Ozs7d0JBR0wsS0FBSzs7Ozt5QkFHSixLQUFLOzs7OytCQUdDLEtBQUs7Ozt3QkFJYixJQUFJOzs7NkJBSUMsSUFBSTs7Ozs7OzBCQUtMLElBQUk7Ozs7OzRCQUllLElBQUk7Ozs7a0NBR0UsSUFBSTs7Ozs7O3dCQUtoQyxLQUFLOzs7Ozs7Ozs7b0NBUStDLElBQUk7Ozs7NEJBR2xDLElBQUk7Ozs7Ozs7Ozs7K0JBU3lCLElBQUk7Ozs7Ozs7Ozs7K0JBVWhELElBQUk7Ozs7O3FCQUlmLENBQUM7Ozs7O3NCQUlBLENBQUM7Ozs7OzsyQkFLSyxJQUFJOzs7Ozs7NEJBS0gsSUFBSTs7Ozs7O2lDQUtDLElBQUk7Ozs7MkJBR1YsS0FBSzs7OzsrQkFHRCxLQUFLOzs7OzsyQkFJVCxLQUFLOzs7Ozs7Ozs7O2dDQVVBLEtBQUs7Ozs7a0NBR0gsSUFBSTs7Ozt3QkFHZCxLQUFLOzs7Ozs7cUNBS3dCLElBQUk7Ozs7OztxQ0FLSixJQUFJOzs7Ozs7OEJBSzVCLEVBQUU7Ozs7O29DQUl3QixJQUFJOzs7O3lCQUduQyxZQUFZOzs7Ozs4QkFJUCxJQUFJOzs7OzZCQUdMLGdCQUFnQjs7Ozs7a0NBSVgsSUFBSTs7OzsrQkFHUCxJQUFJOzs7OzRCQUdQLElBQUk7Ozs7dUJBR1IsSUFBSTs7Ozs2QkFHRSxLQUFLOztDQUNoQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50ZXJUeXBlIH0gZnJvbSAnLi9wb2ludGVyLXR5cGUnO1xuXG4vKiogTGFiZWwgdHlwZSAqL1xuZXhwb3J0IGVudW0gTGFiZWxUeXBlIHtcbiAgLyoqIExhYmVsIGFib3ZlIGxvdyBwb2ludGVyICovXG4gIExvdyxcbiAgLyoqIExhYmVsIGFib3ZlIGhpZ2ggcG9pbnRlciAqL1xuICBIaWdoLFxuICAvKiogTGFiZWwgZm9yIG1pbmltdW0gc2xpZGVyIHZhbHVlICovXG4gIEZsb29yLFxuICAvKiogTGFiZWwgZm9yIG1heGltdW0gc2xpZGVyIHZhbHVlICovXG4gIENlaWwsXG4gIC8qKiBMYWJlbCBiZWxvdyBsZWdlbmQgdGljayAqL1xuICBUaWNrVmFsdWVcbn1cblxuLyoqIEZ1bmN0aW9uIHRvIHRyYW5zbGF0ZSBsYWJlbCB2YWx1ZSBpbnRvIHRleHQgKi9cbmV4cG9ydCB0eXBlIFRyYW5zbGF0ZUZ1bmN0aW9uID0gKHZhbHVlOiBudW1iZXIsIGxhYmVsOiBMYWJlbFR5cGUpID0+IHN0cmluZztcbi8qKiBGdW5jdGlvbiB0byBjb21iaW5kICovXG5leHBvcnQgdHlwZSBDb21iaW5lTGFiZWxzRnVuY3Rpb24gPSAobWluTGFiZWw6IHN0cmluZywgbWF4TGFiZWw6IHN0cmluZykgPT4gc3RyaW5nO1xuLyoqIEZ1bmN0aW9uIHRvIHByb3ZpZGUgbGVnZW5kICAqL1xuZXhwb3J0IHR5cGUgR2V0TGVnZW5kRnVuY3Rpb24gPSAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nO1xuZXhwb3J0IHR5cGUgR2V0U3RlcExlZ2VuZEZ1bmN0aW9uID0gKHN0ZXA6IEN1c3RvbVN0ZXBEZWZpbml0aW9uKSA9PiBzdHJpbmc7XG5cbi8qKiBGdW5jdGlvbiBjb252ZXJ0aW5nIHNsaWRlciB2YWx1ZSB0byBzbGlkZXIgcG9zaXRpb24gKi9cbmV4cG9ydCB0eXBlIFZhbHVlVG9Qb3NpdGlvbkZ1bmN0aW9uID0gKHZhbDogbnVtYmVyLCBtaW5WYWw6IG51bWJlciwgbWF4VmFsOiBudW1iZXIpID0+IG51bWJlcjtcblxuLyoqIEZ1bmN0aW9uIGNvbnZlcnRpbmcgc2xpZGVyIHBvc2l0aW9uIHRvIHNsaWRlciB2YWx1ZSAqL1xuZXhwb3J0IHR5cGUgUG9zaXRpb25Ub1ZhbHVlRnVuY3Rpb24gPSAocGVyY2VudDogbnVtYmVyLCBtaW5WYWw6IG51bWJlciwgbWF4VmFsOiBudW1iZXIpID0+IG51bWJlcjtcblxuLyoqXG4gKiBDdXN0b20gc3RlcCBkZWZpbml0aW9uXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGN1c3RvbSB2YWx1ZXMgYW5kIGxlZ2VuZCB2YWx1ZXMgZm9yIHNsaWRlciB0aWNrc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbVN0ZXBEZWZpbml0aW9uIHtcbiAgLyoqIFZhbHVlICovXG4gIHZhbHVlOiBudW1iZXI7XG4gIC8qKiBMZWdlbmQgKGxhYmVsIGZvciB0aGUgdmFsdWUpICovXG4gIGxlZ2VuZD86IHN0cmluZztcbn1cblxuLyoqIFNsaWRlciBvcHRpb25zICovXG5leHBvcnQgY2xhc3MgT3B0aW9ucyB7XG4gIC8qKiBNaW5pbXVtIHZhbHVlIGZvciBhIHNsaWRlci5cbiAgICBOb3QgYXBwbGljYWJsZSB3aGVuIHVzaW5nIHN0ZXBzQXJyYXkuICovXG4gIGZsb29yPzogbnVtYmVyID0gMDtcblxuICAvKiogTWF4aW11bSB2YWx1ZSBmb3IgYSBzbGlkZXIuXG4gICAgTm90IGFwcGxpY2FibGUgd2hlbiB1c2luZyBzdGVwc0FycmF5LiAqL1xuICBjZWlsPzogbnVtYmVyID0gbnVsbDtcblxuICAvKiogU3RlcCBiZXR3ZWVuIGVhY2ggdmFsdWUuXG4gICAgTm90IGFwcGxpY2FibGUgd2hlbiB1c2luZyBzdGVwc0FycmF5LiAqL1xuICBzdGVwPzogbnVtYmVyID0gMTtcblxuICAvKiogVGhlIG1pbmltdW0gcmFuZ2UgYXV0aG9yaXplZCBvbiB0aGUgc2xpZGVyLlxuICAgIEFwcGxpZXMgdG8gcmFuZ2Ugc2xpZGVyIG9ubHkuXG4gICAgV2hlbiB1c2luZyBzdGVwc0FycmF5LCBleHByZXNzZWQgYXMgaW5kZXggaW50byBzdGVwc0FycmF5LiAqL1xuICBtaW5SYW5nZT86IG51bWJlciA9IG51bGw7XG5cbiAgLyoqIFRoZSBtYXhpbXVtIHJhbmdlIGF1dGhvcml6ZWQgb24gdGhlIHNsaWRlci5cbiAgICBBcHBsaWVzIHRvIHJhbmdlIHNsaWRlciBvbmx5LlxuICAgIFdoZW4gdXNpbmcgc3RlcHNBcnJheSwgZXhwcmVzc2VkIGFzIGluZGV4IGludG8gc3RlcHNBcnJheS4gKi9cbiAgbWF4UmFuZ2U/OiBudW1iZXIgPSBudWxsO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBoYXZlIGEgcHVzaCBiZWhhdmlvci4gV2hlbiB0aGUgbWluIGhhbmRsZSBnb2VzIGFib3ZlIHRoZSBtYXgsXG4gICAgdGhlIG1heCBpcyBtb3ZlZCBhcyB3ZWxsIChhbmQgdmljZS12ZXJzYSkuIFRoZSByYW5nZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGlzXG4gICAgZGVmaW5lZCBieSB0aGUgc3RlcCBvcHRpb24gKGRlZmF1bHRzIHRvIDEpIGFuZCBjYW4gYWxzbyBiZSBvdmVycmlkZW4gYnlcbiAgICB0aGUgbWluUmFuZ2Ugb3B0aW9uLiBBcHBsaWVzIHRvIHJhbmdlIHNsaWRlciBvbmx5LiAqL1xuICBwdXNoUmFuZ2U/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHZhbHVlIGF1dGhvcml6ZWQgb24gdGhlIHNsaWRlci5cbiAgICBXaGVuIHVzaW5nIHN0ZXBzQXJyYXksIGV4cHJlc3NlZCBhcyBpbmRleCBpbnRvIHN0ZXBzQXJyYXkuICovXG4gIG1pbkxpbWl0PzogbnVtYmVyID0gbnVsbDtcblxuICAvKiogVGhlIG1heGltdW0gdmFsdWUgYXV0aG9yaXplZCBvbiB0aGUgc2xpZGVyLlxuICAgIFdoZW4gdXNpbmcgc3RlcHNBcnJheSwgZXhwcmVzc2VkIGFzIGluZGV4IGludG8gc3RlcHNBcnJheS4gKi9cbiAgbWF4TGltaXQ/OiBudW1iZXIgPSBudWxsO1xuXG4gIC8qKiBDdXN0b20gdHJhbnNsYXRlIGZ1bmN0aW9uLiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byB0cmFuc2xhdGUgdmFsdWVzIGRpc3BsYXllZFxuICAgICAgb24gdGhlIHNsaWRlci4gKi9cbiAgdHJhbnNsYXRlPzogVHJhbnNsYXRlRnVuY3Rpb24gPSBudWxsO1xuXG4gIC8qKiBDdXN0b20gZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBvdmVybGFwcGluZyBsYWJlbHMgaW4gcmFuZ2Ugc2xpZGVyLlxuICAgICAgSXQgdGFrZXMgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyAoYWxyZWFkeSB0cmFuc2xhdGVkIHdpdGggdHJhbnNsYXRlIGZ1Y3Rpb24pXG4gICAgICBhbmQgc2hvdWxkIHJldHVybiBob3cgdGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuXG4gICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIHdpbGwgam9pbiB0aGUgdHdvIHZhbHVlcyB3aXRoXG4gICAgICAnIC0gJyBhcyBzZXBhcmF0b3IuICovXG4gIGNvbWJpbmVMYWJlbHM/OiBDb21iaW5lTGFiZWxzRnVuY3Rpb24gPSBudWxsO1xuXG4gIC8qKiBVc2UgdG8gZGlzcGxheSBsZWdlbmQgdW5kZXIgdGlja3MgKHRodXMsIGl0IG5lZWRzIHRvIGJlIHVzZWQgYWxvbmcgd2l0aFxuICAgICBzaG93VGlja3Mgb3Igc2hvd1RpY2tzVmFsdWVzKS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCB0aWNrXG4gICAgIHZhbHVlIGFuZCByZXR1cm5lZCBjb250ZW50IHdpbGwgYmUgZGlzcGxheWVkIHVuZGVyIHRoZSB0aWNrIGFzIGEgbGVnZW5kLlxuICAgICBJZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVsbCwgdGhlbiBubyBsZWdlbmQgaXMgZGlzcGxheWVkIHVuZGVyXG4gICAgIHRoZSBjb3JyZXNwb25kaW5nIHRpY2suWW91IGNhbiBhbHNvIGRpcmVjdGx5IHByb3ZpZGUgdGhlIGxlZ2VuZCB2YWx1ZXNcbiAgICAgaW4gdGhlIHN0ZXBzQXJyYXkgb3B0aW9uLiAqL1xuICBnZXRMZWdlbmQ/OiBHZXRMZWdlbmRGdW5jdGlvbiA9IG51bGw7XG5cbiAgIC8qKiBVc2UgdG8gZGlzcGxheSBhIGN1c3RvbSBsZWdlbmQgb2YgYSBzdGVwSXRlbSBmcm9tIHN0ZXBzQXJyYXkuXG4gICAgSXQgd2lsbCBiZSB0aGUgc2FtZSBhcyBnZXRMZWdlbmQgYnV0IGZvciBzdGVwc0FycmF5LiAqL1xuICBnZXRTdGVwTGVnZW5kPzogR2V0U3RlcExlZ2VuZEZ1bmN0aW9uID0gbnVsbDtcblxuICAvKiogSWYgeW91IHdhbnQgdG8gZGlzcGxheSBhIHNsaWRlciB3aXRoIG5vbiBsaW5lYXIvbnVtYmVyIHN0ZXBzLlxuICAgICBKdXN0IHBhc3MgYW4gYXJyYXkgd2l0aCBlYWNoIHNsaWRlciB2YWx1ZSBhbmQgdGhhdCdzIGl0OyB0aGUgZmxvb3IsIGNlaWwgYW5kIHN0ZXAgc2V0dGluZ3NcbiAgICAgb2YgdGhlIHNsaWRlciB3aWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgIEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSBtb2RlbCBhbmQgdmFsdWVIaWdoIG1vZGVsIHZhbHVlcyB3aWxsIGJlIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgICBpbiB0aGUgc3RlcHNBcnJheS5cbiAgICAgVGhleSBjYW4gYWxzbyBiZSBib3VuZCB0byB0aGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGl0ZW0gYnkgc2V0dGluZyB0aGUgYmluZEluZGV4Rm9yU3RlcHNBcnJheVxuICAgICBvcHRpb24gdG8gdHJ1ZS4gKi9cbiAgc3RlcHNBcnJheT86IEN1c3RvbVN0ZXBEZWZpbml0aW9uW10gPSBudWxsO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBiaW5kIHRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgaXRlbSB0byB2YWx1ZSBtb2RlbCBhbmQgdmFsdWVIaWdoIG1vZGVsLiAqL1xuICBiaW5kSW5kZXhGb3JTdGVwc0FycmF5PzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBXaGVuIHNldCB0byB0cnVlIGFuZCB1c2luZyBhIHJhbmdlIHNsaWRlciwgdGhlIHJhbmdlIGNhbiBiZSBkcmFnZ2VkIGJ5IHRoZSBzZWxlY3Rpb24gYmFyLlxuICAgIEFwcGxpZXMgdG8gcmFuZ2Ugc2xpZGVyIG9ubHkuICovXG4gIGRyYWdnYWJsZVJhbmdlPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBTYW1lIGFzIGRyYWdnYWJsZVJhbmdlIGJ1dCB0aGUgc2xpZGVyIHJhbmdlIGNhbid0IGJlIGNoYW5nZWQuXG4gICAgQXBwbGllcyB0byByYW5nZSBzbGlkZXIgb25seS4gKi9cbiAgZHJhZ2dhYmxlUmFuZ2VPbmx5PzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBhbHdheXMgc2hvdyB0aGUgc2VsZWN0aW9uIGJhciBiZWZvcmUgdGhlIHNsaWRlciBoYW5kbGUuICovXG4gIHNob3dTZWxlY3Rpb25CYXI/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGFsd2F5cyBzaG93IHRoZSBzZWxlY3Rpb24gYmFyIGFmdGVyIHRoZSBzbGlkZXIgaGFuZGxlLiAqL1xuICBzaG93U2VsZWN0aW9uQmFyRW5kPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiAgU2V0IGEgbnVtYmVyIHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBiYXIgYmV0d2VlbiB0aGlzIHZhbHVlIGFuZCB0aGUgc2xpZGVyIGhhbmRsZS5cbiAgICBXaGVuIHVzaW5nIHN0ZXBzQXJyYXksIGV4cHJlc3NlZCBhcyBpbmRleCBpbnRvIHN0ZXBzQXJyYXkuICovXG4gIHNob3dTZWxlY3Rpb25CYXJGcm9tVmFsdWU/OiBudW1iZXIgPSBudWxsO1xuXG4gIC8qKiAgT25seSBmb3IgcmFuZ2Ugc2xpZGVyLiBTZXQgdG8gdHJ1ZSB0byB2aXN1YWxpemUgaW4gZGlmZmVyZW50IGNvbG91ciB0aGUgYXJlYXNcbiAgICBvbiB0aGUgbGVmdC9yaWdodCAodG9wL2JvdHRvbSBmb3IgdmVydGljYWwgcmFuZ2Ugc2xpZGVyKSBvZiBzZWxlY3Rpb24gYmFyIGJldHdlZW4gdGhlIGhhbmRsZXMuICovXG4gIHNob3dPdXRlclNlbGVjdGlvbkJhcnM/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGhpZGUgcG9pbnRlciBsYWJlbHMgKi9cbiAgaGlkZVBvaW50ZXJMYWJlbHM/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGhpZGUgbWluIC8gbWF4IGxhYmVscyAgKi9cbiAgaGlkZUxpbWl0TGFiZWxzPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgYXV0by1oaWRpbmcgYmVoYXZpb3Igb2YgdGhlIGxpbWl0IGxhYmVscy4gKi9cbiAgYXV0b0hpZGVMaW1pdExhYmVscz86IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBtYWtlIHRoZSBzbGlkZXIgcmVhZC1vbmx5LiAqL1xuICByZWFkT25seT86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGUgc2xpZGVyLiAqL1xuICBkaXNhYmxlZD86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogU2V0IHRvIHRydWUgdG8gZGlzcGxheSBhIHRpY2sgZm9yIGVhY2ggc3RlcCBvZiB0aGUgc2xpZGVyLiAqL1xuICBzaG93VGlja3M/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGRpc3BsYXkgYSB0aWNrIGFuZCB0aGUgc3RlcCB2YWx1ZSBmb3IgZWFjaCBzdGVwIG9mIHRoZSBzbGlkZXIuLiAqL1xuICBzaG93VGlja3NWYWx1ZXM/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyogVGhlIHN0ZXAgYmV0d2VlbiBlYWNoIHRpY2sgdG8gZGlzcGxheS4gSWYgbm90IHNldCwgdGhlIHN0ZXAgdmFsdWUgaXMgdXNlZC5cbiAgICBOb3QgdXNlZCB3aGVuIHRpY2tzQXJyYXkgaXMgc3BlY2lmaWVkLiAqL1xuICB0aWNrU3RlcD86IG51bWJlciA9IG51bGw7XG5cbiAgLyogVGhlIHN0ZXAgYmV0d2VlbiBkaXNwbGF5aW5nIGVhY2ggdGljayBzdGVwIHZhbHVlLlxuICAgIElmIG5vdCBzZXQsIHRoZW4gdGlja1N0ZXAgb3Igc3RlcCBpcyB1c2VkLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lIGlzIHNldC4gKi9cbiAgdGlja1ZhbHVlU3RlcD86IG51bWJlciA9IG51bGw7XG5cbiAgLyoqIFVzZSB0byBkaXNwbGF5IHRpY2tzIGF0IHNwZWNpZmljIHBvc2l0aW9ucy5cbiAgICBUaGUgYXJyYXkgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSB0aWNrcyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAgRm9yIGV4YW1wbGUsIFswLCAxLCA1XSB3aWxsIGRpc3BsYXkgYSB0aWNrIGZvciB0aGUgZmlyc3QsIHNlY29uZCBhbmQgc2l4dGggdmFsdWVzLiAqL1xuICB0aWNrc0FycmF5PzogbnVtYmVyW10gPSBudWxsO1xuXG4gIC8qKiBVc2VkIHRvIGRpc3BsYXkgYSB0b29sdGlwIHdoZW4gYSB0aWNrIGlzIGhvdmVyZWQuXG4gICAgU2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0b29sdGlwIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gdmFsdWUuICovXG4gIHRpY2tzVG9vbHRpcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBTYW1lIGFzIHRpY2tzVG9vbHRpcCBidXQgZm9yIHRpY2tzIHZhbHVlcy4gKi9cbiAgdGlja3NWYWx1ZXNUb29sdGlwPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZyA9IG51bGw7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGRpc3BsYXkgdGhlIHNsaWRlciB2ZXJ0aWNhbGx5LlxuICAgIFRoZSBzbGlkZXIgd2lsbCB0YWtlIHRoZSBmdWxsIGhlaWdodCBvZiBpdHMgcGFyZW50LlxuICAgIENoYW5naW5nIHRoaXMgdmFsdWUgYXQgcnVudGltZSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4gKi9cbiAgdmVydGljYWw/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBjb2xvciBvZiB0aGUgc2VsZWN0aW9uIGJhci5cbiAgICBJZiB5b3VyIGNvbG9yIHdvbid0IGNoYW5nZSwgZG9uJ3QgdXNlIHRoaXMgb3B0aW9uIGJ1dCBzZXQgaXQgdGhyb3VnaCBDU1MuXG4gICAgSWYgdGhlIHJldHVybmVkIGNvbG9yIGRlcGVuZHMgb24gYSBtb2RlbCB2YWx1ZSAoZWl0aGVyIHZhbHVlIG9yIHZhbHVlSGlnaCksXG4gICAgeW91IHNob3VsZCB1c2UgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAgSW5kZWVkLCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZXJlIGlzIG5vIGNlcnRhaW50eSB0aGF0IHRoZSBtb2RlbFxuICAgIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZC4qL1xuICBnZXRTZWxlY3Rpb25CYXJDb2xvcj86IChtaW5WYWx1ZTogbnVtYmVyLCBtYXhWYWx1ZT86IG51bWJlcikgPT4gc3RyaW5nID0gbnVsbDtcblxuICAvKiogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjb2xvciBvZiBhIHRpY2suIHNob3dUaWNrcyBtdXN0IGJlIGVuYWJsZWQuICovXG4gIGdldFRpY2tDb2xvcj86ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgY29sb3Igb2YgYSBwb2ludGVyLlxuICAgIElmIHlvdXIgY29sb3Igd29uJ3QgY2hhbmdlLCBkb24ndCB1c2UgdGhpcyBvcHRpb24gYnV0IHNldCBpdCB0aHJvdWdoIENTUy5cbiAgICBJZiB0aGUgcmV0dXJuZWQgY29sb3IgZGVwZW5kcyBvbiBhIG1vZGVsIHZhbHVlIChlaXRoZXIgdmFsdWUgb3IgdmFsdWVIaWdoKSxcbiAgICB5b3Ugc2hvdWxkIHVzZSB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAgICBJbmRlZWQsIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gY2VydGFpbnR5IHRoYXQgdGhlIG1vZGVsIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZC5cbiAgICBUbyBoYW5kbGUgcmFuZ2Ugc2xpZGVyIHBvaW50ZXJzIGluZGVwZW5kZW50bHksIHlvdSBzaG91bGQgZXZhbHVhdGUgcG9pbnRlclR5cGUgd2l0aGluIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIHdoZXJlIFwibWluXCIgc3RhbmRzIGZvciB2YWx1ZSBtb2RlbCBhbmQgXCJtYXhcIiBmb3IgdmFsdWVIaWdoIG1vZGVsIHZhbHVlcy4gKi9cbiAgZ2V0UG9pbnRlckNvbG9yPzogKHZhbHVlOiBudW1iZXIsIHBvaW50ZXJUeXBlOiBQb2ludGVyVHlwZSkgPT4gc3RyaW5nID0gbnVsbDtcblxuICAvKiogSGFuZGxlcyBhcmUgZm9jdXNhYmxlIChvbiBjbGljayBvciB3aXRoIHRhYikgYW5kIGNhbiBiZSBtb2RpZmllZCB1c2luZyB0aGUgZm9sbG93aW5nIGtleWJvYXJkIGNvbnRyb2xzOlxuICAgIExlZnQvYm90dG9tIGFycm93czogLTFcbiAgICBSaWdodC90b3AgYXJyb3dzOiArMVxuICAgIFBhZ2UtZG93bjogLTEwJVxuICAgIFBhZ2UtdXA6ICsxMCVcbiAgICBIb21lOiBtaW5pbXVtIHZhbHVlXG4gICAgRW5kOiBtYXhpbXVtIHZhbHVlXG4gICAqL1xuICBrZXlib2FyZFN1cHBvcnQ/OiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogSWYgeW91IGRpc3BsYXkgdGhlIHNsaWRlciBpbiBhbiBlbGVtZW50IHRoYXQgdXNlcyB0cmFuc2Zvcm06IHNjYWxlKDAuNSksIHNldCB0aGUgc2NhbGUgdmFsdWUgdG8gMlxuICAgIHNvIHRoYXQgdGhlIHNsaWRlciBpcyByZW5kZXJlZCBwcm9wZXJseSBhbmQgdGhlIGV2ZW50cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuICovXG4gIHNjYWxlPzogbnVtYmVyID0gMTtcblxuICAvKiogSWYgeW91IGRpc3BsYXkgdGhlIHNsaWRlciBpbiBhbiBlbGVtZW50IHRoYXQgdXNlcyB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyksIHNldCB0aGUgcm90YXRlIHZhbHVlIHRvIDkwXG4gICBzbyB0aGF0IHRoZSBzbGlkZXIgaXMgcmVuZGVyZWQgcHJvcGVybHkgYW5kIHRoZSBldmVudHMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LiBWYWx1ZSBpcyBpbiBkZWdyZWVzLiAqL1xuICByb3RhdGU/OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgdmFsdWUocykgdG8gYmUgcm91bmRlZCB0byB0aGUgc3RlcCwgZXZlbiB3aGVuIG1vZGlmaWVkIGZyb20gdGhlIG91dHNpZGUuXG4gICAgV2hlbiBzZXQgdG8gZmFsc2UsIGlmIHRoZSBtb2RlbCB2YWx1ZXMgYXJlIG1vZGlmaWVkIGZyb20gb3V0c2lkZSB0aGUgc2xpZGVyLCB0aGV5IGFyZSBub3Qgcm91bmRlZFxuICAgIGFuZCBjYW4gYmUgYmV0d2VlbiB0d28gc3RlcHMuICovXG4gIGVuZm9yY2VTdGVwPzogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIGZvcmNlIHRoZSB2YWx1ZShzKSB0byBiZSBub3JtYWxpc2VkIHRvIGFsbG93ZWQgcmFuZ2UgKGZsb29yIHRvIGNlaWwpLCBldmVuIHdoZW4gbW9kaWZpZWQgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICBXaGVuIHNldCB0byBmYWxzZSwgaWYgdGhlIG1vZGVsIHZhbHVlcyBhcmUgbW9kaWZpZWQgZnJvbSBvdXRzaWRlIHRoZSBzbGlkZXIsIGFuZCB0aGV5IGFyZSBvdXRzaWRlIGFsbG93ZWQgcmFuZ2UsXG4gICAgdGhlIHNsaWRlciBtYXkgYmUgcmVuZGVyZWQgaW5jb3JyZWN0bHkuIEhvd2V2ZXIsIHNldHRpbmcgdGhpcyB0byBmYWxzZSBtYXkgYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHBlcmZvcm0gY3VzdG9tIG5vcm1hbGlzYXRpb24uICovXG4gIGVuZm9yY2VSYW5nZT86IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgdmFsdWUocykgdG8gYmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBzdGVwIHZhbHVlLCBldmVuIHdoZW4gbW9kaWZpZWQgZnJvbSB0aGUgb3V0c2lkZS5cbiAgICBXaGVuIHNldCB0byBmYWxzZSwgaWYgdGhlIG1vZGVsIHZhbHVlcyBhcmUgbW9kaWZpZWQgZnJvbSBvdXRzaWRlIHRoZSBzbGlkZXIsIGFuZCB0aGV5IGFyZSBvdXRzaWRlIGFsbG93ZWQgcmFuZ2UsXG4gICAgdGhlIHNsaWRlciBtYXkgYmUgcmVuZGVyZWQgaW5jb3JyZWN0bHkuIEhvd2V2ZXIsIHNldHRpbmcgdGhpcyB0byBmYWxzZSBtYXkgYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHBlcmZvcm0gY3VzdG9tIG5vcm1hbGlzYXRpb24uICovXG4gIGVuZm9yY2VTdGVwc0FycmF5PzogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdG8gdXNlciBmcm9tIHN3aXRjaGluZyB0aGUgbWluIGFuZCBtYXggaGFuZGxlcy4gQXBwbGllcyB0byByYW5nZSBzbGlkZXIgb25seS4gKi9cbiAgbm9Td2l0Y2hpbmc/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIG9ubHkgYmluZCBldmVudHMgb24gc2xpZGVyIGhhbmRsZXMuICovXG4gIG9ubHlCaW5kSGFuZGxlcz86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogU2V0IHRvIHRydWUgdG8gc2hvdyBncmFwaHMgcmlnaHQgdG8gbGVmdC5cbiAgICBJZiB2ZXJ0aWNhbCBpcyB0cnVlIGl0IHdpbGwgYmUgZnJvbSB0b3AgdG8gYm90dG9tIGFuZCBsZWZ0IC8gcmlnaHQgYXJyb3cgZnVuY3Rpb25zIHJldmVyc2VkLiAqL1xuICByaWdodFRvTGVmdD86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogU2V0IHRvIHRydWUgdG8gcmV2ZXJzZSBrZXlib2FyZCBuYXZpZ2F0aW9uOlxuICAgIFJpZ2h0L3RvcCBhcnJvd3M6IC0xXG4gICAgTGVmdC9ib3R0b20gYXJyb3dzOiArMVxuICAgIFBhZ2UtdXA6IC0xMCVcbiAgICBQYWdlLWRvd246ICsxMCVcbiAgICBFbmQ6IG1pbmltdW0gdmFsdWVcbiAgICBIb21lOiBtYXhpbXVtIHZhbHVlXG4gICAqL1xuICByZXZlcnNlZENvbnRyb2xzPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBTZXQgdG8gdHJ1ZSB0byBrZWVwIHRoZSBzbGlkZXIgbGFiZWxzIGluc2lkZSB0aGUgc2xpZGVyIGJvdW5kcy4gKi9cbiAgYm91bmRQb2ludGVyTGFiZWxzPzogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqIFNldCB0byB0cnVlIHRvIHVzZSBhIGxvZ2FyaXRobWljIHNjYWxlIHRvIGRpc3BsYXkgdGhlIHNsaWRlci4gICovXG4gIGxvZ1NjYWxlPzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgZm9yIGEgZ2l2ZW4gdmFsdWUuXG4gICAgVGhlIHBvc2l0aW9uIG11c3QgYmUgYSBwZXJjZW50YWdlIGJldHdlZW4gMCBhbmQgMS5cbiAgICBUaGUgZnVuY3Rpb24gc2hvdWxkIGJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBvciBkZWNyZWFzaW5nOyBvdGhlcndpc2UgdGhlIHNsaWRlciBtYXkgYmVoYXZlIGluY29ycmVjdGx5LiAqL1xuICBjdXN0b21WYWx1ZVRvUG9zaXRpb24/OiBWYWx1ZVRvUG9zaXRpb25GdW5jdGlvbiA9IG51bGw7XG5cbiAgLyoqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4gcG9zaXRpb24gb24gdGhlIHNsaWRlci5cbiAgICBUaGUgcG9zaXRpb24gaXMgYSBwZXJjZW50YWdlIGJldHdlZW4gMCBhbmQgMS5cbiAgICBUaGUgZnVuY3Rpb24gc2hvdWxkIGJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBvciBkZWNyZWFzaW5nOyBvdGhlcndpc2UgdGhlIHNsaWRlciBtYXkgYmVoYXZlIGluY29ycmVjdGx5LiAqL1xuICBjdXN0b21Qb3NpdGlvblRvVmFsdWU/OiBQb3NpdGlvblRvVmFsdWVGdW5jdGlvbiA9IG51bGw7XG5cbiAgLyoqIFByZWNpc2lvbiBsaW1pdCBmb3IgY2FsY3VsYXRlZCB2YWx1ZXMuXG4gICAgVmFsdWVzIHVzZWQgaW4gY2FsY3VsYXRpb25zIHdpbGwgYmUgcm91bmRlZCB0byB0aGlzIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcbiAgICB0byBwcmV2ZW50IGFjY3VtdWxhdGluZyBzbWFsbCBmbG9hdGluZy1wb2ludCBlcnJvcnMuICovXG4gIHByZWNpc2lvbkxpbWl0PzogbnVtYmVyID0gMTI7XG5cbiAgLyoqIFVzZSB0byBkaXNwbGF5IHRoZSBzZWxlY3Rpb24gYmFyIGFzIGEgZ3JhZGllbnQuXG4gICAgVGhlIGdpdmVuIG9iamVjdCBtdXN0IGNvbnRhaW4gZnJvbSBhbmQgdG8gcHJvcGVydGllcyB3aGljaCBhcmUgY29sb3JzLiAqL1xuICBzZWxlY3Rpb25CYXJHcmFkaWVudD86IHtmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmd9ID0gbnVsbDtcblxuICAvKiogVXNlIHRvIGFkZCBhIGxhYmVsIGRpcmVjdGx5IHRvIHRoZSBzbGlkZXIgZm9yIGFjY2Vzc2liaWxpdHkuIEFkZHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlLiAqL1xuICBhcmlhTGFiZWw/OiBzdHJpbmcgPSAnbmd4LXNsaWRlcic7XG5cbiAgLyoqIFVzZSBpbnN0ZWFkIG9mIGFyaWFMYWJlbCB0byByZWZlcmVuY2UgdGhlIGlkIG9mIGFuIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGxhYmVsIHRoZSBzbGlkZXIuXG4gICAgQWRkcyB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZS4gKi9cbiAgYXJpYUxhYmVsbGVkQnk/OiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBVc2UgdG8gYWRkIGEgbGFiZWwgZGlyZWN0bHkgdG8gdGhlIHNsaWRlciByYW5nZSBmb3IgYWNjZXNzaWJpbGl0eS4gQWRkcyB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUuICovXG4gIGFyaWFMYWJlbEhpZ2g/OiBzdHJpbmcgPSAnbmd4LXNsaWRlci1tYXgnO1xuXG4gIC8qKiBVc2UgaW5zdGVhZCBvZiBhcmlhTGFiZWxIaWdoIHRvIHJlZmVyZW5jZSB0aGUgaWQgb2YgYW4gZWxlbWVudCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gbGFiZWwgdGhlIHNsaWRlciByYW5nZS5cbiAgICBBZGRzIHRoZSBhcmlhLWxhYmVsbGVkYnkgYXR0cmlidXRlLiAqL1xuICBhcmlhTGFiZWxsZWRCeUhpZ2g/OiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBVc2UgdG8gaW5jcmVhc2UgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJZiB0aGUgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgc2xpZGVyIGNhbGN1bGF0ZXMgdGhlIHdpdGgvaGVpZ2h0IG9mIHRoZSBoYW5kbGUgKi9cbiAgaGFuZGxlRGltZW5zaW9uPzogbnVtYmVyID0gbnVsbDtcblxuICAvKiogVXNlIHRvIGluY3JlYXNlIHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSWYgdGhlIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHNsaWRlciBjYWxjdWxhdGVzIHRoZSB3aXRoL2hlaWdodCBvZiB0aGUgYmFyICovXG4gIGJhckRpbWVuc2lvbj86IG51bWJlciA9IG51bGw7XG5cbiAgLyoqIEVuYWJsZS9kaXNhYmxlIENTUyBhbmltYXRpb25zICovXG4gIGFuaW1hdGU/OiBib29sZWFuID0gdHJ1ZTtcblxuICAvKiogRW5hYmxlL2Rpc2FibGUgQ1NTIGFuaW1hdGlvbnMgd2hpbGUgbW92aW5nIHRoZSBzbGlkZXIgKi9cbiAgYW5pbWF0ZU9uTW92ZT86IGJvb2xlYW4gPSBmYWxzZTtcbn1cbiJdfQ==